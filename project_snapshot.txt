é¡¹ç›®ï¼šCyberSurvivor_Pro å…¨é‡ä»£ç å¿«ç…§
æŠ€æœ¯æ ˆï¼šPython 3.14 + pygame-ce 2.5.6
èµ„äº§ç›®å½•è¯´æ˜ï¼šassets æ–‡ä»¶å¤¹ç”¨äºå­˜æ”¾åç»­çš„è´´å›¾(textures)ã€éŸ³æ•ˆ(sfx)å’Œå­—ä½“(fonts)


==============================
FILE: core\camera.py
==============================
import pygame
from core.constants import *


class CameraGroup(pygame.sprite.Group):
    def __init__(self):
        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.offset = pygame.math.Vector2()

    def custom_draw(self, player):
        # 1. æ‘„åƒæœºä¸æ»‘è·Ÿéšé€»è¾‘
        # 0.1 æ˜¯å¹³æ»‘ç³»æ•°ï¼Œæ•°å€¼è¶Šå°è¶Šä¸æ»‘ï¼Œç©å®¶ç¦»ä¸­å¿ƒå°±è¶Šè¿œ
        self.offset.x += (player.rect.centerx - WIDTH // 2 - self.offset.x) * 0.1
        self.offset.y += (player.rect.centery - HEIGHT // 2 - self.offset.y) * 0.1

        # 2. å¡«å……åº•è‰²
        self.display_surface.fill(COLOR_BG)

        # 3. ç»˜åˆ¶æ— é™ç½‘æ ¼ (æ ¸å¿ƒå‚è€ƒç‰©)
        # æ ¹æ®æ‘„åƒæœºåç§»è®¡ç®—ç½‘æ ¼çš„èµ·å§‹ä½ç½®
        grid_range = 2  # ç»˜åˆ¶èŒƒå›´å€æ•°
        start_x = -int(self.offset.x % TILE_SIZE)
        start_y = -int(self.offset.y % TILE_SIZE)

        for x in range(start_x - TILE_SIZE, WIDTH + TILE_SIZE, TILE_SIZE):
            pygame.draw.line(self.display_surface, COLOR_GRID, (x, 0), (x, HEIGHT))
        for y in range(start_y - TILE_SIZE, HEIGHT + TILE_SIZE, TILE_SIZE):
            pygame.draw.line(self.display_surface, COLOR_GRID, (0, y), (WIDTH, y))

        # 4. æ’åºç»˜åˆ¶æ‰€æœ‰ç²¾çµ (Y-sort ä¼ª3D)
        for sprite in sorted(self.sprites(), key=lambda s: (getattr(s, 'z_index', 0), s.rect.centery)):
            offset_pos = sprite.rect.topleft - self.offset
            self.display_surface.blit(sprite.image, offset_pos)
==============================
FILE: core\constants.py
==============================
import pygame
WIDTH, HEIGHT = 1280, 720
FPS = 60
TILE_SIZE = 64
LAYER_BG, LAYER_PICKUP, LAYER_ENEMY, LAYER_PLAYER, LAYER_PROJECTILE, LAYER_UI = 0, 10, 20, 30, 40, 100
COLOR_BG = (12, 12, 20)
COLOR_GRID = (35, 35, 55)
COLOR_PLAYER = (0, 255, 240)
COLOR_ENEMY = (255, 50, 80)
==============================
FILE: core\engine.py
==============================
import pygame
import sys
from core.constants import *
from core.registry import registry
from ui.ui_manager import UIManager
from ui.menus.hud import HUD
from ui.menus.upgrade_panel import UpgradePanel
from core.event_bus import bus

# å¯¼å…¥æˆ‘ä»¬çš„æ–°åœºæ™¯
from systems.menu_scene import MenuScene
from systems.combat_scene import CombatScene


class GameEngine:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True

        # 1. å…¨å±€æ•°æ®åŠ è½½
        registry.load()
        from combat.weapon_factory import WeaponFactory
        WeaponFactory.auto_discover_logic()

        # 2. UI ç®¡ç†å™¨ (å…¨å±€å­˜åœ¨)
        self.ui_manager = UIManager(self)
        self.player_dummy = type('obj', (object,),
                                 {'current_hp': 0, 'current_xp': 0, 'xp_required': 100, 'level': 1})  # ä¸´æ—¶å ä½
        self.ui_manager.add_menu('hud', HUD(self.player_dummy))
        self.ui_manager.add_menu('upgrade', UpgradePanel(self.player_dummy))

        # 3. åœºæ™¯æ§åˆ¶
        self.scene = None
        self.state = "MAIN_MENU"
        self.score = 0
        self.switch_scene("MENU")

        bus.subscribe("RESUME_GAME", self.resume)

    def switch_scene(self, scene_type):
        """æ ¸å¿ƒï¼šåˆ‡æ¢åœºæ™¯çš„æ–¹æ³•"""
        if scene_type == "MENU":
            self.scene = MenuScene(self)
            self.state = "MAIN_MENU"
        elif scene_type == "COMBAT":
            self.scene = CombatScene(self)
            self.state = "PLAYING"
            # æˆ˜æ–—å¼€å§‹åï¼Œè¦æŠŠ HUD çš„ç©å®¶å¯¹è±¡æ›´æ–°ä¸ºçœŸæ­£çš„ç©å®¶
            self.ui_manager.menus['hud'].player = self.scene.player
            self.ui_manager.menus['upgrade'].player = self.scene.player

    def resume(self):
        self.state = "PLAYING"

    def on_enemy_killed(self, enemy):
        """å…¨å±€æ­»äº¡å›è°ƒ"""
        self.score += enemy.config.get("score_value", 10)
        from entities.pickups.exp_gem import ExperienceGem
        # ç»éªŒå®çŸ³éœ€è¦åŠ å…¥åˆ°å½“å‰åœºæ™¯çš„ç»„é‡Œ
        ExperienceGem(enemy.rect.center, [self.scene.all_sprites, self.scene.gem_group], self.scene.player)

    # core/engine.py çš„ run æ–¹æ³•ä¸­çš„å¾ªç¯éƒ¨åˆ†å»ºè®®å¦‚ä¸‹ï¼š

    def run(self):
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False

                # æš‚åœé€»è¾‘æ‹¦æˆª
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if self.state == "PLAYING":
                            self.state = "PAUSED"
                        elif self.state == "PAUSED":
                            self.state = "PLAYING"

            # é€»è¾‘åˆ†å‘
            if self.state == "MAIN_MENU":
                self.scene.update(dt)
            elif self.state == "PLAYING":
                self.scene.update(dt)
                self.ui_manager.update(dt)
            # æ³¨æ„ï¼šPAUSED çŠ¶æ€ä¸‹ä¸æ›´æ–° scene é€»è¾‘ï¼Œä»è€Œå®ç°â€œç”»é¢å‡å›ºâ€

            # æ¸²æŸ“åˆ†å‘ (ä¿æŒä½ ä¹‹å‰çš„ä»£ç ç»“æ„)
            if self.state == "MAIN_MENU":
                self.scene.draw()
            else:
                self.scene.draw()
                self.ui_manager.draw(self.score)

            pygame.display.flip()


if __name__ == '__main__':
    GameEngine().run()
==============================
FILE: core\event_bus.py
==============================
class EventBus:
    """
    äº‹ä»¶æ€»çº¿ï¼šè§£è€¦ç¥å™¨ã€‚
    è®©ä¸åŒçš„ç³»ç»Ÿï¼ˆå¦‚ï¼šå‡çº§ç³»ç»Ÿå’Œå¼•æ“ï¼‰é€šè¿‡å‘é€æ¶ˆæ¯é€šä¿¡ï¼Œè€Œä¸æ˜¯ç›´æ¥è°ƒç”¨ã€‚
    """
    def __init__(self):
        self.listeners = {}

    def subscribe(self, event_type, callback):
        if event_type not in self.listeners:
            self.listeners[event_type] = []
        self.listeners[event_type].append(callback)

    def emit(self, event_type, **kwargs):
        if event_type in self.listeners:
            for callback in self.listeners[event_type]:
                callback(**kwargs)

# åˆ›å»ºå…¨å±€å”¯ä¸€çš„å®ä¾‹
bus = EventBus()
==============================
FILE: core\registry.py
==============================
# core/registry.py
import os
import json
import pygame


class Registry:
    def __init__(self):
        # 1. ç»“æ„åŒ–å­˜å‚¨ï¼šåˆ†ç±»å­˜æ”¾æ‰€æœ‰ JSON é…ç½®
        self.weapons = {}
        self.enemies = {}
        self.characters = {}
        self.waves = {}  # é¢„ç•™ç»™æœªæ¥çš„æ³¢æ¬¡ç³»ç»Ÿ
        self.upgrades = []

        # 2. é€»è¾‘æ˜ å°„ï¼šå­˜æ”¾ Python ç±»é€»è¾‘ (ç”±è£…é¥°å™¨æ³¨å…¥)
        self.weapon_logic = {}

        # 3. èµ„äº§åº“ï¼šå­˜æ”¾åŠ è½½å¥½çš„ Surface å¯¹è±¡
        self.textures = {}

    def register_logic(self, logic_id):
        """è§„åˆ™ï¼šä½¿ç”¨è£…é¥°å™¨å°† Python ç±»å…³è”åˆ° JSON é…ç½®çš„ logic_type"""

        def wrapper(cls):
            self.weapon_logic[logic_id] = cls
            return cls

        return wrapper

    def load_all(self):
        """è§„åˆ™ï¼šä¸€é”®å¯åŠ¨æ‰€æœ‰è§„åˆ™åŒ–åŠ è½½"""
        self._load_configs()
        self._load_assets()
        print(f"ğŸš€ Registry å…¨é‡åŒæ­¥å®Œæˆ")

    def _load_configs(self):
        """è§„åˆ™ï¼šé…ç½®é©±åŠ¨ã€‚åªéœ€å¢åŠ å­—å…¸é¡¹å³å¯æ”¯æŒæ–°ç±»å‹ JSON"""
        config_map = {
            'weapons': 'data/configs/weapons',
            'enemies': 'data/configs/enemies',
            'characters': 'data/configs/characters',
            'waves': 'data/configs/waves'
        }

        for attr, path in config_map.items():
            if not os.path.exists(path):
                continue

            for f in os.listdir(path):
                if f.endswith(".json"):
                    try:
                        with open(os.path.join(path, f), 'r', encoding='utf-8') as file:
                            data = json.load(file)
                            # è§„åˆ™ï¼šæ‰€æœ‰é…ç½®æ–‡ä»¶å¿…é¡»åŒ…å« 'id' å­—æ®µä½œä¸º Key
                            if 'id' in data:
                                getattr(self, attr)[data['id']] = data
                    except Exception as e:
                        print(f"âŒ é…ç½®æ–‡ä»¶è§£æå¤±è´¥ [{f}]: {e}")

        # ç‹¬ç«‹å¤„ç†ç‰¹æ®Šçš„æ•°ç»„å‹é…ç½®
        upgrade_file = "data/configs/upgrades.json"
        if os.path.exists(upgrade_file):
            with open(upgrade_file, 'r', encoding='utf-8') as f:
                self.upgrades = json.load(f)

    def _load_assets(self):
        """è§„åˆ™ï¼šèµ„äº§è‡ªåŠ¨å‘ç°ã€‚æ‰«æ assets/textures ä¸‹æ‰€æœ‰å›¾ç‰‡ï¼Œè‡ªåŠ¨ç”Ÿæˆå±‚çº§ ID"""
        base_path = "assets/textures"
        if not os.path.exists(base_path):
            os.makedirs(base_path, exist_ok=True)
            return

        for root, _, files in os.walk(base_path):
            for f in files:
                if f.lower().endswith(('.png', '.jpg', '.webp')):
                    full_path = os.path.join(root, f)

                    # è§„åˆ™ï¼šå°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸º IDã€‚
                    # ä¾‹å¦‚: assets/textures/ui/icons/hp.png -> ID: 'ui/icons/hp'
                    rel_path = os.path.relpath(full_path, base_path)
                    asset_id = os.path.splitext(rel_path)[0].replace("\\", "/")

                    try:
                        # è‡ªåŠ¨å¤„ç†é€æ˜åº¦å¹¶ä¼˜åŒ–æ¸²æŸ“æ•ˆç‡
                        surf = pygame.image.load(full_path).convert_alpha()
                        self.textures[asset_id] = surf
                    except Exception as e:
                        print(f"âŒ èµ„äº§åŠ è½½å¤±è´¥ [{asset_id}]: {e}")

    def get_texture(self, asset_id, fallback_color=(255, 0, 255)):
        """è§„åˆ™ï¼šå®‰å…¨çš„èµ„äº§è·å–ã€‚å¦‚æœè´´å›¾ç¼ºå¤±ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªç´«è‰²æ–¹å—è¡¥ä¸"""
        if asset_id in self.textures:
            return self.textures[asset_id]

        # å·¥ä¸šçº§è¡¥æ•‘ï¼šåŠ¨æ€ç”Ÿæˆé”™è¯¯æç¤ºå›¾
        print(f"âš ï¸ èµ„äº§ç¼ºå¤±: {asset_id}ï¼Œå·²ç”Ÿæˆå ä½ç¬¦")
        error_surf = pygame.Surface((32, 32))
        error_surf.fill(fallback_color)
        self.textures[asset_id] = error_surf
        return error_surf


# åˆ›å»ºå…¨å±€å•ä¾‹
registry = Registry()
==============================
FILE: core\save_manager.py
==============================
# core/save_manager.py
import json
import os

class SaveManager:
    def __init__(self):
        self.path = "data/save.json"
        self.data = {
            "currency": 0,
            "unlocked_characters": ["cypher_ghost"],
            "meta_upgrades": {"hp": 0, "atk": 0, "speed": 0},
            "achievements": []
        }
        self.load()

    def load(self):
        if os.path.exists(self.path):
            with open(self.path, "r") as f:
                self.data.update(json.load(f))

    def save(self):
        os.makedirs("data", exist_ok=True)
        with open(self.path, "w") as f:
            json.dump(self.data, f, indent=4)

save_manager = SaveManager()
==============================
FILE: core\__init__.py
==============================

==============================
FILE: systems\base_scene.py
==============================
import pygame

class BaseScene:
    """æ‰€æœ‰åœºæ™¯çš„åŸºç±»ï¼šèœå•ã€æˆ˜æ–—ã€ç»“ç®—éƒ½ç»§æ‰¿è‡ªå®ƒ"""
    def __init__(self, engine):
        self.engine = engine
        self.screen = pygame.display.get_surface()

    def update(self, dt):
        pass

    def draw(self):
        pass
==============================
FILE: systems\combat_scene.py
==============================
import pygame
import random
from systems.base_scene import BaseScene
from core.constants import *
from core.registry import registry
from core.camera import CameraGroup
from entities.player import Player
from combat.weapon_manager import WeaponManager
from combat.weapon_factory import WeaponFactory
from combat.damage_system import DamageSystem
from entities.enemies.base_enemy import Enemy
from ui.menus.hud import HUD
from ui.menus.upgrade_panel import UpgradePanel

class CombatScene(BaseScene):
    def __init__(self, engine):
        super().__init__(engine)
        # 1. åˆå§‹åŒ–æ˜¾ç¤ºä¸ç‰©ç†ç»„
        self.all_sprites = CameraGroup()
        self.enemy_group = pygame.sprite.Group()
        self.projectile_group = pygame.sprite.Group()
        self.gem_group = pygame.sprite.Group()

        # 2. åˆ›å»ºæ ¸å¿ƒå®ä½“ (æŠŠ engine ä¼ ç»™ Player ä»¥ä¾¿å®ƒè®¿é—® ui_manager)
        self.player = Player((WIDTH // 2, HEIGHT // 2), [self.all_sprites], engine)
        self.spawn_timer = 0

        # 3. åˆå§‹åŒ–æ­¦å™¨ç®¡ç†å™¨
        self.weapon_manager = WeaponManager(
            self.player,
            self.enemy_group,
            [self.all_sprites, self.projectile_group]
        )
        self.weapon_manager.add_or_upgrade_weapon("starter_gun")

        # 4. è·å– HUD å’Œ å‡çº§é¢æ¿çš„å¼•ç”¨
        self.hud = engine.ui_manager.menus['hud']
        self.upgrade_panel = engine.ui_manager.menus['upgrade']

    def update(self, dt):
        # åˆ·æ€ªé€»è¾‘
        self.spawn_timer += dt
        if self.spawn_timer >= 1.5:
            self._spawn_enemy()
            self.spawn_timer = 0

        # ç³»ç»Ÿæ›´æ–°
        self.all_sprites.update(dt)
        self.weapon_manager.update(dt)

        # ç¢°æ’å¤„ç†ï¼šå­å¼¹ vs æ•Œäºº
        hits = pygame.sprite.groupcollide(self.enemy_group, self.projectile_group, False, False)
        for enemy, bullets in hits.items():
            for bullet in bullets:
                self.engine.ui_manager.spawn_damage_text(enemy.rect.center, bullet.damage)
                if DamageSystem.handle_collision(bullet, enemy):
                    self.engine.on_enemy_killed(enemy)

        # å…¨å±€æ­»äº¡æ£€æµ‹ (é’ˆå¯¹å…‰ç¯æ€æ•Œ)
        for enemy in self.enemy_group:
            if enemy.hp <= 0:
                self.engine.on_enemy_killed(enemy)
                enemy.kill()

        # ç©å®¶å—å‡»ä¸æ¡å®çŸ³ (é€»è¾‘åŒåŸ engine.py)
        if pygame.sprite.spritecollide(self.player, self.enemy_group, False):
            self.player.take_damage(1)

        gems_hit = pygame.sprite.spritecollide(self.player, self.gem_group, True)
        for gem in gems_hit:
            self.player.gain_xp(gem.xp_value)
            if self.player.current_xp >= self.player.xp_required:
                self.player.perform_level_up()
                self.engine.state = "UPGRADING"
                self.upgrade_panel.show()

    def draw(self):
        # æ¸²æŸ“æµæ°´çº¿
        self.all_sprites.custom_draw(self.player)
        self.weapon_manager.draw_weapons(self.screen, self.all_sprites.offset)

    def _spawn_enemy(self):
        angle = random.uniform(0, 360)
        dist = 850
        spawn_pos = self.player.pos + pygame.math.Vector2(1, 0).rotate(angle) * dist
        config = registry.enemies.get("basic_grunt")
        if config:
            Enemy(spawn_pos, [self.all_sprites, self.enemy_group], config, self.player)
==============================
FILE: systems\menu_scene.py
==============================
# systems/menu_scene.py
import pygame
from systems.base_scene import BaseScene
from ui.components import CyberButton
from core.constants import *
from core.save_manager import save_manager
from core.registry import registry  # å¿…é¡»å¯¼å…¥æ³¨å†Œä¸­å¿ƒ


class MenuScene(BaseScene):
    def __init__(self, engine):
        super().__init__(engine)
        self.state = "MAIN"

        # å­—ä½“åˆå§‹åŒ–
        self.font_title = pygame.font.SysFont("impact", 90)
        self.font_sub = pygame.font.SysFont("microsoftyahei", 30, bold=True)
        self.font_info = pygame.font.SysFont("microsoftyahei", 18)

        # 1. è§’è‰²åˆ—è¡¨ä¸ç´¢å¼• (ä¸€åŠ³æ°¸é€¸çš„æ ¸å¿ƒ)
        self.char_list = list(registry.characters.values())
        self.char_index = 0

        # 2. æŒ‰é’®å®šä¹‰
        self.main_btns = {
            "A": CyberButton("ä½œæˆ˜ä¸­å¿ƒ (COMBAT HUB)", (100, 250), (350, 50), self.font_sub),
            "B": CyberButton("ç¥ç»å¢å¼º (META-UPGRADES)", (100, 320), (350, 50), self.font_sub),
            "C": CyberButton("æ¡£æ¡ˆåº“ (ARCHIVE)", (100, 390), (350, 50), self.font_sub),
            "D": CyberButton("åè®®é…ç½® (SETTINGS)", (100, 460), (350, 50), self.font_sub),
            "E": CyberButton("åˆ‡æ–­è¿æ¥ (QUIT)", (100, 530), (350, 50), self.font_sub)
        }

        # ä½œæˆ˜ä¸­å¿ƒä¸“ç”¨åˆ‡æ¢æŒ‰é’®
        self.prev_btn = CyberButton("<", (WIDTH // 2 - 260, 300), (50, 50), self.font_sub)
        self.next_btn = CyberButton(">", (WIDTH // 2 + 210, 300), (50, 50), self.font_sub)
        self.start_btn = CyberButton("åŒæ­¥æ„è¯† (START)", (WIDTH // 2 - 125, 550), (250, 60), self.font_sub,
                                     color=(255, 200, 0))

        self.back_btn = CyberButton("è¿”å›ä¸Šä¸€çº§", (WIDTH - 250, HEIGHT - 100), (200, 50), self.font_sub)

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        clicked = pygame.mouse.get_pressed()[0]

        if self.state == "MAIN":
            for btn in self.main_btns.values(): btn.update(mouse_pos)
            if clicked:
                if self.main_btns["A"].is_hovered:
                    self.state = "COMBAT_HUB"
                elif self.main_btns["B"].is_hovered:
                    self.state = "UPGRADES"
                elif self.main_btns["E"].is_hovered:
                    pygame.quit(); import sys; sys.exit()
                if any(b.is_hovered for b in self.main_btns.values()): pygame.time.delay(150)

        elif self.state == "COMBAT_HUB":
            # æ›´æ–°åˆ‡æ¢å’Œå¼€å§‹æŒ‰é’®
            self.prev_btn.update(mouse_pos)
            self.next_btn.update(mouse_pos)
            self.start_btn.update(mouse_pos)
            self.back_btn.update(mouse_pos)

            if clicked:
                if self.prev_btn.is_hovered:
                    self.char_index = (self.char_index - 1) % len(self.char_list)
                    pygame.time.delay(150)
                elif self.next_btn.is_hovered:
                    self.char_index = (self.char_index + 1) % len(self.char_list)
                    pygame.time.delay(150)
                elif self.start_btn.is_hovered:
                    # å…³é”®ç‚¹ï¼šå°†å½“å‰é€‰ä¸­çš„è§’è‰²é…ç½®ä¼ ç»™ CombatScene
                    selected_char = self.char_list[self.char_index]
                    self.engine.switch_scene("COMBAT", selected_char)
                elif self.back_btn.is_hovered:
                    self.state = "MAIN"
                    pygame.time.delay(150)

        elif self.state != "MAIN":
            self.back_btn.update(mouse_pos)
            if clicked and self.back_btn.is_hovered:
                self.state = "MAIN"
                pygame.time.delay(150)

    def draw(self):
        self.screen.fill((5, 5, 10))
        self._draw_background_fx()

        if self.state == "MAIN":
            self._draw_main_menu()
        elif self.state == "COMBAT_HUB":
            self._draw_combat_hub()
        elif self.state == "UPGRADES":
            self._draw_meta_upgrades()
        elif self.state == "SETTINGS":
            self._draw_settings()

        if self.state != "MAIN": self.back_btn.draw(self.screen)

    def _draw_background_fx(self):
        for x in range(0, WIDTH, 50): pygame.draw.line(self.screen, (15, 15, 30), (x, 0), (x, HEIGHT))
        for y in range(0, HEIGHT, 50): pygame.draw.line(self.screen, (15, 15, 30), (0, y), (WIDTH, y))

    def _draw_main_menu(self):
        title = self.font_title.render("CYBER SURVIVOR", True, (0, 255, 240))
        self.screen.blit(title, (100, 100))
        pygame.draw.line(self.screen, (255, 0, 255), (100, 200), (600, 200), 3)
        for btn in self.main_btns.values(): btn.draw(self.screen)

    def _draw_combat_hub(self):
        # æ ¸å¿ƒé€»è¾‘ï¼šè·å–å½“å‰æŒ‡å‘çš„è§’è‰²æ•°æ®
        if not self.char_list: return  # é˜²æ­¢é…ç½®ä¸¢å¤±æŠ¥é”™
        char = self.char_list[self.char_index]

        # æ ‡é¢˜
        txt = self.font_sub.render(f"--- é€»è¾‘ä½“éƒ¨ç½²: {char['name']} ---", True, (0, 255, 240))
        self.screen.blit(txt, (WIDTH // 2 - txt.get_width() // 2, 80))

        # 1. è§’è‰²é¢„è§ˆåŒº (èµ„äº§æ¥å£é¢„ç•™)
        preview_rect = pygame.Rect(WIDTH // 2 - 150, 150, 300, 300)
        pygame.draw.rect(self.screen, (20, 20, 40), preview_rect, border_radius=15)
        # TODO: åœ¨æ­¤åŠ è½½è´´å›¾ if char['id'] in assets: screen.blit(...)
        # ç›®å‰ä½¿ç”¨é¢œè‰²å ä½ï¼Œé‡é‡‘å±å’Œå¹½çµæ˜¾ç¤ºä¸åŒé¢œè‰²
        placeholder_color = (0, 255, 240) if "ghost" in char['id'] else (255, 50, 80)
        pygame.draw.circle(self.screen, placeholder_color, preview_rect.center, 60)

        # 2. è§’è‰²æè¿°
        desc_txt = self.font_info.render(char['desc'], True, (200, 200, 200))
        self.screen.blit(desc_txt, (WIDTH // 2 - desc_txt.get_width() // 2, 470))

        # 3. åˆå§‹æ­¦å™¨æç¤º
        weapon_hint = self.font_info.render(f"åˆå§‹åè®®: {char.get('starting_weapon', 'N/A')}", True, (255, 255, 0))
        self.screen.blit(weapon_hint, (WIDTH // 2 - weapon_hint.get_width() // 2, 500))

        # 4. ç»˜åˆ¶äº¤äº’æŒ‰é’®
        self.prev_btn.draw(self.screen)
        self.next_btn.draw(self.screen)
        self.start_btn.draw(self.screen)

    def _draw_meta_upgrades(self):
        txt = self.font_sub.render("--- ç¥ç»å›è·¯å¢å¼º ---", True, (255, 0, 255))
        self.screen.blit(txt, (WIDTH // 2 - txt.get_width() // 2, 100))
        y_offset = 200
        for stat, val in save_manager.data["meta_upgrades"].items():
            stat_txt = self.font_info.render(f"{stat.upper()} åŠ æˆå±‚çº§: {val}", True, (200, 200, 200))
            self.screen.blit(stat_txt, (WIDTH // 2 - 100, y_offset))
            y_offset += 50

    def _draw_settings(self):
        txt = self.font_sub.render("--- æ ¸å¿ƒåè®®é…ç½® ---", True, (200, 200, 200))
        self.screen.blit(txt, (WIDTH // 2 - txt.get_width() // 2, 100))
==============================
FILE: systems\__init__.py
==============================

==============================
FILE: ui\components.py
==============================
# ui/components.py
import pygame


class CyberButton:
    """èµ›åšé£æ ¼å‘å…‰æŒ‰é’®"""

    def __init__(self, text, pos, size, font, color=(0, 255, 240)):
        self.text = text
        self.rect = pygame.Rect(pos, size)
        self.font = font
        self.base_color = pygame.Color(*color)
        self.is_hovered = False
        self.glow_anim = 0.0  # åŠ¨ç”»è¿›åº¦

    def update(self, mouse_pos):
        self.is_hovered = self.rect.collidepoint(mouse_pos)
        # å‘¼å¸ç¯é€»è¾‘ï¼šæ‚¬åœæ—¶å‘å…‰å¢å¼º
        if self.is_hovered:
            self.glow_anim = min(1.0, self.glow_anim + 0.1)
        else:
            self.glow_anim = max(0.0, self.glow_anim - 0.05)

    def draw(self, surface):
        # 1. ç»˜åˆ¶å¤–å‘å…‰åº•è‰²
        if self.glow_anim > 0:
            # è¿™é‡Œçš„ inflate ç¨å¾®æ‰©å¤§ä¸€ç‚¹çŸ©å½¢ä½œä¸ºå‘å…‰èŒƒå›´
            glow_rect = self.rect.inflate(int(self.glow_anim * 12), int(self.glow_anim * 12))
            glow_color = (*self.base_color[:3], int(self.glow_anim * 50))
            glow_surf = pygame.Surface(glow_rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surf, glow_color, glow_surf.get_rect(), border_radius=8)
            surface.blit(glow_surf, glow_rect.topleft)

        # 2. ç»˜åˆ¶ä¸»è¾¹æ¡†
        current_color = self.base_color if self.is_hovered else self.base_color.lerp((0, 0, 0, 255), 0.5)
        pygame.draw.rect(surface, current_color, self.rect, 2, border_radius=4)

        # 3. æ ¸å¿ƒä¿®å¤ï¼šç»˜åˆ¶å››ä¸ªè£…é¥°è§’ (ä½¿ç”¨ Vector2 é¿å…å…ƒç»„æ‹¼æ¥é”™è¯¯)
        l = 10  # è§’çº¿é•¿åº¦
        tl = pygame.Vector2(self.rect.topleft)
        tr = pygame.Vector2(self.rect.topright)
        bl = pygame.Vector2(self.rect.bottomleft)
        br = pygame.Vector2(self.rect.bottomright)

        # å·¦ä¸Šè§’
        pygame.draw.lines(surface, self.base_color, False, [tl + (0, l), tl, tl + (l, 0)], 3)
        # å³ä¸‹è§’
        pygame.draw.lines(surface, self.base_color, False, [br - (0, l), br, br - (l, 0)], 3)

        # 4. æ–‡å­—ç»˜åˆ¶
        t_surf = self.font.render(self.text, True, current_color)
        t_rect = t_surf.get_rect(center=self.rect.center)
        surface.blit(t_surf, t_rect)
==============================
FILE: ui\ui_manager.py
==============================
# ui/ui_manager.py (å…¨é‡æ›¿æ¢)
import pygame
import random
from core.constants import *


class UIManager:
    def __init__(self, engine):
        self.engine = engine
        self.display_surface = pygame.display.get_surface()
        self.floating_texts = []
        self.menus = {}

    def add_menu(self, name, instance):
        self.menus[name] = instance

    def spawn_damage_text(self, pos, amount):
        font = pygame.font.SysFont("arial", 24, bold=True)
        txt_surf = font.render(str(int(amount)), True, (255, 255, 255))

        self.floating_texts.append({
            'pos': pygame.Vector2(pos),
            'surf': txt_surf,
            'life': 1.0,
            'vel': pygame.Vector2(random.uniform(-30, 30), -60)
        })

    def update(self, dt):
        for text in self.floating_texts[:]:
            text['pos'] += text['vel'] * dt
            text['life'] -= dt
            if text['life'] <= 0:
                self.floating_texts.remove(text)

    def draw(self, score):
        # 1. åªæœ‰åœ¨æˆ˜æ–—åœºæ™¯æ—¶æ‰ç”»ä¼¤å®³æ•°å­—
        # é€šè¿‡æ£€æŸ¥å½“å‰ scene æ˜¯å¦æœ‰ 'all_sprites' å±æ€§æ¥åˆ¤å®š
        if hasattr(self.engine.scene, 'all_sprites'):
            self._draw_floating_texts()

        # 2. æ¸²æŸ“å¸¸é©» HUD (HUD å†…éƒ¨å·²æœ‰å®‰å…¨åˆ¤å®š)
        if 'hud' in self.menus:
            self.menus['hud'].draw(score)

        # 3. æ¸²æŸ“å‡çº§é¢æ¿
        if self.engine.state == "UPGRADING" and 'upgrade' in self.menus:
            self.menus['upgrade'].draw()

    def _draw_floating_texts(self):
        # æ ¸å¿ƒä¿®å¤ç‚¹ï¼šä»å½“å‰ scene è·å– all_sprites çš„ offset
        offset = self.engine.scene.all_sprites.offset
        for text in self.floating_texts:
            alpha = int(text['life'] * 255)
            text['surf'].set_alpha(alpha)
            render_pos = text['pos'] - offset
            self.display_surface.blit(text['surf'], render_pos)
==============================
FILE: ui\__init__.py
==============================

==============================
FILE: ui\menus\hud.py
==============================
# ui/menus/hud.py (å…¨é‡æ›¿æ¢)
import pygame
from core.constants import *


class HUD:
    def __init__(self, player):
        self.player = player
        self.display_surface = pygame.display.get_surface()
        self.font = pygame.font.SysFont("consolas", 20, bold=True)

        self.smooth_hp = player.current_hp
        self.smooth_xp = player.current_xp

    def draw(self, score):
        # å¦‚æœå½“å‰æ²¡æœ‰çœŸæ­£çš„ç©å®¶å¯¹è±¡ï¼ˆæ¯”å¦‚åœ¨ dummy é˜¶æ®µï¼‰ï¼Œç›´æ¥è·³è¿‡
        if not hasattr(self.player, 'stats'): return

        self.smooth_hp += (self.player.current_hp - self.smooth_hp) * 0.1
        self.smooth_xp += (self.player.current_xp - self.smooth_xp) * 0.1

        self._draw_hp_bar()
        self._draw_xp_bar()
        self._draw_stats(score)
        self._draw_weapon_icons()

    def _draw_hp_bar(self):
        x, y, w, h = 30, 40, 250, 14
        pygame.draw.rect(self.display_surface, (40, 40, 50), (x, y, w, h), border_radius=4)
        max_hp = self.player.stats.max_health.value
        if max_hp > 0:
            fill_w = w * (max(0, self.smooth_hp) / max_hp)
            pygame.draw.rect(self.display_surface, (255, 50, 80), (x, y, fill_w, h), border_radius=4)
        pygame.draw.rect(self.display_surface, (200, 200, 210), (x, y, w, h), 2, border_radius=4)

    def _draw_xp_bar(self):
        xp_ratio = self.smooth_xp / self.player.xp_required
        pygame.draw.rect(self.display_surface, (20, 20, 30), (0, HEIGHT - 10, WIDTH, 10))
        pygame.draw.rect(self.display_surface, (0, 255, 200), (0, HEIGHT - 10, WIDTH * xp_ratio, 10))

    def _draw_stats(self, score):
        info_str = f"SCORE: {score:06d} | LVL: {self.player.level}"
        info_surf = self.font.render(info_str, True, (0, 255, 240))
        self.display_surface.blit(info_surf, (WIDTH - 280, 30))

        now_ms = pygame.time.get_ticks() // 1000
        time_str = f"{now_ms // 60:02d}:{now_ms % 60:02d}"
        t_surf = self.font.render(time_str, True, (255, 255, 255))
        self.display_surface.blit(t_surf, (WIDTH // 2 - t_surf.get_width() // 2, 20))

    def _draw_weapon_icons(self):
        """æ ¸å¿ƒä¿®å¤ç‚¹ï¼šé€‚é…åœºæ™¯åŒ–æ¶æ„"""
        start_x, y, size = 30, 75, 30

        # 1. å…ˆæ£€æŸ¥ engine æ˜¯å¦æœ‰æ´»è·ƒåœºæ™¯
        scene = getattr(self.player.engine, 'scene', None)
        # 2. æ£€æŸ¥åœºæ™¯æ˜¯å¦æ˜¯æˆ˜æ–—åœºæ™¯ï¼ˆå³æ˜¯å¦æœ‰ weapon_managerï¼‰
        weapon_manager = getattr(scene, 'weapon_manager', None)

        if not weapon_manager:
            return

        owned_weapons = list(weapon_manager.weapons.values())
        for i in range(6):
            rect = pygame.Rect(start_x + i * (size + 8), y, size, size)
            pygame.draw.rect(self.display_surface, (30, 30, 40), rect, border_radius=4)
            if i < len(owned_weapons):
                pygame.draw.rect(self.display_surface, (0, 255, 240, 100), rect, 2, border_radius=4)
                lvl_txt = self.font.render(str(owned_weapons[i].level), True, (255, 255, 255))
                self.display_surface.blit(lvl_txt, (rect.x + 8, rect.y + 4))
==============================
FILE: ui\menus\upgrade_panel.py
==============================
# ui/menus/upgrade_panel.py (å…¨é‡æ›¿æ¢)
import pygame
import random
from core.constants import *
from core.registry import registry
from core.event_bus import bus

class UpgradePanel:
    def __init__(self, player):
        self.player = player
        self.display_surface = pygame.display.get_surface()

        # åŠ è½½æ”¯æŒä¸­æ–‡çš„å­—ä½“
        self.font_title = self._get_font(28)
        self.font_desc = self._get_font(18)
        self.font_button = self._get_font(22)

        self.visible = False
        self.options = []
        self.show_time = 0
        self.input_delay = 500

        self.reroll_count = 1
        self.reroll_rect = pygame.Rect(WIDTH // 2 - 60, HEIGHT - 100, 120, 45)

    @staticmethod
    def _get_font(size):
        for f in ['microsoftyahei', 'simhei', 'arial']:
            font = pygame.font.SysFont(f, size, bold=True)
            if font.size("æµ‹è¯•")[0] > 0: return font
        return pygame.font.SysFont(None, size)

    def show(self):
        self._generate_options()
        self.visible = True
        self.show_time = pygame.time.get_ticks()

    def _generate_options(self):
        """æ ¸å¿ƒä¿®å¤ç‚¹ï¼šé€šè¿‡å½“å‰åœºæ™¯è·å–æ­¦å™¨ç®¡ç†å™¨"""
        pool = []
        # 1. å±æ€§æ±  (ä» Registry åŠ è½½)
        for item in registry.upgrades:
            pool.append({"type": "stat", "name": item['name'], "desc": item['desc'], "raw_data": item})

        # 2. æ­¦å™¨æ±  (ä¿®å¤ï¼šå»å½“å‰æ´»è·ƒåœºæ™¯ scene æ‰¾ weapon_manager)
        scene = self.player.engine.scene
        if hasattr(scene, 'weapon_manager'):
            weapon_cands = scene.weapon_manager.get_upgrade_candidates()
            for cand in weapon_cands:
                w_name = registry.weapons[cand['id']]['name']
                w_desc = "æ–°æ­¦å™¨è·å¾—" if cand['type'] == 'weapon_new' else f"å‡çº§è‡³ LV.{cand['level']}"
                pool.append({"type": cand['type'], "name": w_name, "desc": w_desc, "raw_data": cand})

        # éšæœºæŠ½å– 3 ä¸ª
        count = min(3, len(pool))
        self.options = random.sample(pool, count)

    def reroll(self):
        if self.reroll_count > 0:
            self.reroll_count -= 1
            self._generate_options()
            self.show_time = pygame.time.get_ticks()

    def draw(self):
        if not self.visible: return
        now = pygame.time.get_ticks()
        mouse_pos = pygame.mouse.get_pos()
        clicked = pygame.mouse.get_pressed()[0]

        # è’™ç‰ˆåŠé€æ˜èƒŒæ™¯
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 210))
        self.display_surface.blit(overlay, (0, 0))

        # ç»˜åˆ¶å¡ç‰‡
        card_w, card_h = 280, 380
        start_x = (WIDTH - (card_w * len(self.options) + 40 * (len(self.options) - 1))) // 2

        for i, opt in enumerate(self.options):
            rect = pygame.Rect(start_x + i * (card_w + 40), (HEIGHT - card_h) // 2, card_w, card_h)
            is_hover = rect.collidepoint(mouse_pos)

            color = (70, 75, 100) if is_hover else (45, 48, 62)
            pygame.draw.rect(self.display_surface, color, rect, border_radius=15)
            pygame.draw.rect(self.display_surface, (0, 255, 240) if is_hover else (80, 80, 100), rect, 3, border_radius=15)

            # æ–‡å­—
            t_surf = self.font_title.render(opt['name'], True, (255, 255, 255))
            d_surf = self.font_desc.render(opt['desc'], True, (200, 200, 200))
            self.display_surface.blit(t_surf, (rect.x + 20, rect.y + 40))
            self.display_surface.blit(d_surf, (rect.x + 20, rect.y + 100))

            if is_hover and clicked and (now - self.show_time > self.input_delay):
                self.apply_upgrade(opt)
                break

        # åˆ·æ–°æŒ‰é’®
        if self.reroll_count > 0:
            btn_color = (0, 200, 150) if self.reroll_rect.collidepoint(mouse_pos) else (0, 120, 100)
            pygame.draw.rect(self.display_surface, btn_color, self.reroll_rect, border_radius=10)
            btn_txt = self.font_button.render(f"åˆ·æ–° ({self.reroll_count})", True, (255, 255, 255))
            self.display_surface.blit(btn_txt, (self.reroll_rect.centerx - btn_txt.get_width() // 2,
                                                self.reroll_rect.centery - btn_txt.get_height() // 2))
            if self.reroll_rect.collidepoint(mouse_pos) and clicked and (now - self.show_time > self.input_delay):
                self.reroll()

    def apply_upgrade(self, opt):
        """æ ¸å¿ƒä¿®å¤ç‚¹ï¼šé€šè¿‡åœºæ™¯æ‰§è¡Œå‡çº§"""
        raw = opt['raw_data']
        if opt['type'] == 'stat':
            self.player.stats.add_modifier(raw['stat'], raw['value'])
            if raw['stat'] in ["health", "max_health"]:
                self.player.current_hp = self.player.stats.max_health.value
        else:
            # å‡çº§æˆ–è·å–æ­¦å™¨ï¼šåŒæ ·å»å½“å‰åœºæ™¯ scene æ‰¾ weapon_manager
            scene = self.player.engine.scene
            if hasattr(scene, 'weapon_manager'):
                scene.weapon_manager.add_or_upgrade_weapon(raw['id'])

        self.visible = False
        bus.emit("RESUME_GAME")
==============================
FILE: ui\menus\__init__.py
==============================

==============================
FILE: combat\combat_utils.py
==============================
import pygame


class CombatUtils:
    @staticmethod
    def get_nearest_enemy(origin_pos, enemy_group):
        """åœ¨æŒ‡å®šçš„æ•Œäººç»„ä¸­å¯»æ‰¾è·ç¦»åŸç‚¹æœ€è¿‘çš„æ•Œäºº"""
        nearest_enemy = None
        min_dist = float('inf')

        for enemy in enemy_group:
            # è®¡ç®—å‘é‡è·ç¦»
            dist = origin_pos.distance_to(enemy.pos)
            if dist < min_dist:
                min_dist = dist
                nearest_enemy = enemy

        return nearest_enemy
==============================
FILE: combat\damage_system.py
==============================
import pygame


class DamageSystem:
    @staticmethod
    def handle_collision(bullet, enemy):
        # 1. åŸºç¡€ä¼¤å®³è®¡ç®—ï¼ˆæœªæ¥å¯ä»¥åœ¨è¿™é‡ŒåŠ å…¥æš´å‡»åˆ¤å®šï¼‰
        damage = bullet.damage

        # 2. æ•Œäººæ‰£è¡€
        is_dead = enemy.take_damage(damage)

        # 3. å­å¼¹å¤„ç†ï¼ˆç›®å‰ç®€å•å¤„ç†ä¸ºå‘½ä¸­æ¶ˆå¤±ï¼‰
        bullet.kill()

        return is_dead
==============================
FILE: combat\weapon_factory.py
==============================
import importlib
import os
from core.registry import registry


class WeaponFactory:
    @classmethod
    def auto_discover_logic(cls):
        """æ‰«æ weapons æ–‡ä»¶å¤¹å¹¶åŠ¨æ€åŠ è½½æ¨¡å—ä»¥è§¦å‘è£…é¥°å™¨"""
        path = "combat/weapons"
        if not os.path.exists(path): return

        for filename in os.listdir(path):
            if filename.endswith(".py") and filename not in ["__init__.py", "base_weapon.py"]:
                module_name = f"combat.weapons.{filename[:-3]}"
                # åŠ¨æ€åŠ è½½ä¼šæ‰§è¡Œæ¨¡å—ä»£ç ï¼Œä»è€Œè§¦å‘ @registry.register_logic
                importlib.import_module(module_name)

        print(f"ğŸ› ï¸ æ­¦å™¨å·¥å‚ï¼šé€»è¾‘è‡ªåŠ¨å‘ç°å®Œæˆ -> {list(registry.weapon_logic.keys())}")

    @classmethod
    def create_weapon(cls, weapon_id, player, groups):
        config = registry.weapons.get(weapon_id)
        if not config:
            print(f"âš ï¸ æ‰¾ä¸åˆ°æ­¦å™¨é…ç½®: {weapon_id}");
            return None

        logic_id = config.get("logic_type")
        logic_class = registry.weapon_logic.get(logic_id)

        if logic_class:
            return logic_class(player, groups, config)

        print(f"âŒ æ‰¾ä¸åˆ°é€»è¾‘å®ç°: {logic_id}")
        return None
==============================
FILE: combat\weapon_manager.py
==============================
import pygame
from combat.weapon_factory import WeaponFactory

class WeaponManager:
    """
    å·¥ä¸šçº§æ­¦å™¨ç®¡ç†å™¨ï¼š
    1. è´Ÿè´£ 6 ä¸ªæ­¦å™¨æ’æ§½çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚
    2. åè°ƒ WeaponFactory ç”Ÿæˆä¸åŒé€»è¾‘ç±»å‹çš„æ­¦å™¨ï¼ˆå¼¹é“ç±» vs æŒ‚è½½ç±»ï¼‰ã€‚
    3. æä¾›å‡çº§å€™é€‰åˆ—è¡¨ä¾› UI ç³»ç»Ÿè°ƒç”¨ã€‚
    """
    def __init__(self, player, enemy_group, projectile_groups):
        self.player = player
        self.enemy_group = enemy_group
        self.projectile_groups = projectile_groups
        self.max_slots = 6
        self.weapons = {}  # æ ¼å¼ï¼š{ 'weapon_id': weapon_instance }

    def add_or_upgrade_weapon(self, weapon_id):
        """æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼šè‡ªåŠ¨åˆ¤å®šæ˜¯å‡çº§ç°æœ‰æ­¦å™¨è¿˜æ˜¯å ç”¨æ–°æ§½ä½"""
        # 1. æ£€æŸ¥æ˜¯å¦å·²ç»æŒæœ‰è¯¥æ­¦å™¨
        if weapon_id in self.weapons:
            self.weapons[weapon_id].level_up()
            return True

        # 2. æ£€æŸ¥æ’æ§½æ˜¯å¦å·²æ»¡
        if len(self.weapons) < self.max_slots:
            # è°ƒç”¨å·¥å‚åˆ›å»ºå®ä¾‹ï¼Œä¼ å…¥ playerã€æ˜¾ç¤º/ç‰©ç†ç»„ã€ä»¥åŠé…ç½®
            new_weapon = WeaponFactory.create_weapon(weapon_id, self.player, self.projectile_groups)
            if new_weapon:
                self.weapons[weapon_id] = new_weapon
                print(f"âœ… å·²è£…é…æ–°æ­¦å™¨é€»è¾‘: {weapon_id}")
                return True
        else:
            print(f"ğŸš« æ­¦å™¨æ’æ§½å·²æ»¡({self.max_slots})ï¼Œæ— æ³•å­¦ä¹ æ–°æ­¦å™¨: {weapon_id}")
        return False

    def get_upgrade_candidates(self):
        """
        ä¸º UpgradePanel æä¾›å¯é€‰åˆ—è¡¨ã€‚
        åŒ…å«ï¼šæœªæ»¡çº§çš„å·²æœ‰æ­¦å™¨ + åº“ä¸­æœªè·å–çš„æ–°æ­¦å™¨ã€‚
        """
        from core.registry import registry
        candidates = []

        # å€™é€‰é¡¹ A: å·²æœ‰æ­¦å™¨çš„å‡çº§ (Level Up)
        for w_id, w_inst in self.weapons.items():
            if w_inst.level < w_inst.max_level:
                candidates.append({
                    "type": "weapon_upgrade", 
                    "id": w_id, 
                    "level": w_inst.level + 1
                })

        # å€™é€‰é¡¹ B: åº“ä¸­å°šæœªè·å–çš„æ–°æ­¦å™¨ (New Weapon)
        if len(self.weapons) < self.max_slots:
            for w_id in registry.weapons.keys():
                if w_id not in self.weapons:
                    candidates.append({
                        "type": "weapon_new", 
                        "id": w_id
                    })

        return candidates

    def update(self, dt):
        """é©±åŠ¨æ‰€æœ‰å·²è£…å¤‡æ­¦å™¨çš„é€»è¾‘ï¼ˆå¦‚ï¼šå¼€ç«åˆ¤å®šã€å…‰ç¯åˆ¤å®šï¼‰"""
        for weapon in list(self.weapons.values()):
            weapon.update(dt, self.enemy_group)

    def draw_weapons(self, screen, camera_offset):
        """
        ã€æ–°å¢åŠŸèƒ½ã€‘
        è§£å†³éå¼¹é“ç±»æ­¦å™¨ï¼ˆå¦‚èµ›åšå…‰ç¯ã€ç£åœºï¼‰ä¸å¯è§çš„é—®é¢˜ã€‚
        è¿™äº›æ­¦å™¨ä¸æ˜¯ç‹¬ç«‹çš„ Spriteï¼Œå› æ­¤éœ€è¦æ‰‹åŠ¨è§¦å‘å®ƒä»¬çš„ç»˜åˆ¶é€»è¾‘ã€‚
        """
        for weapon in self.weapons.values():
            # å¦‚æœæ­¦å™¨ç±»å®ç°äº† draw_custom æ–¹æ³•ï¼Œåˆ™è¿›è¡Œç»˜åˆ¶
            if hasattr(weapon, 'draw_custom'):
                weapon.draw_custom(screen, camera_offset)

    # --- å·¥ä¸šçº§å…¼å®¹æ€§ç»´æŠ¤ ---
    def add_weapon(self, weapon_instance_or_id):
        """
        ä¿ç•™æ—§æ¥å£å…¼å®¹æ€§ã€‚
        å¦‚æœä¼ å…¥çš„æ˜¯ ID å­—ç¬¦ä¸²ï¼Œè‡ªåŠ¨è½¬å…¥ add_or_upgrade æµç¨‹ã€‚
        """
        if isinstance(weapon_instance_or_id, str):
            self.add_or_upgrade_weapon(weapon_instance_or_id)
        else:
            # å…¼å®¹æ‰‹åŠ¨åˆ›å»ºå®ä¾‹å¹¶ç›´æ¥æ·»åŠ çš„æƒ…å†µ
            w_id = getattr(weapon_instance_or_id, 'id', None)
            if w_id:
                self.weapons[w_id] = weapon_instance_or_id
==============================
FILE: combat\projectiles\bullet.py
==============================
import pygame
from entities.base_entity import BaseEntity
from core.constants import *


class Bullet(BaseEntity):
    def __init__(self, pos, direction, groups, damage):
        super().__init__(pos, groups, LAYER_PROJECTILE)
        # å·¥ä¸šåŒ–ï¼šç¼“å­˜ Surface é˜²æ­¢é‡å¤åˆ›å»º
        self.image = pygame.Surface((12, 6), pygame.SRCALPHA)
        pygame.draw.rect(self.image, (0, 255, 255), (0, 0, 12, 6), border_radius=2)

        # é…åˆé£è¡Œæ–¹å‘æ—‹è½¬å­å¼¹è´´å›¾
        angle = direction.angle_to(pygame.math.Vector2(1, 0))
        self.image = pygame.transform.rotate(self.image, angle)

        self.rect = self.image.get_rect(center=pos)
        self.pos = pygame.math.Vector2(pos)
        self.direction = direction
        self.speed = 1000
        self.damage = damage
        self.spawn_time = pygame.time.get_ticks()

    def update(self, dt):
        self.pos += self.direction * self.speed * dt
        self.rect.center = (round(self.pos.x), round(self.pos.y))
        if pygame.time.get_ticks() - self.spawn_time > 1500:
            self.kill()
==============================
FILE: combat\projectiles\__init__.py
==============================

==============================
FILE: combat\weapons\base_weapon.py
==============================
import pygame

class BaseWeapon:
    """æ‰€æœ‰æ­¦å™¨å¿…é¡»éµå®ˆçš„å·¥ä¸šåè®®"""
    def __init__(self, player, groups, config):
        self.player = player
        self.groups = groups
        self.config = config
        self.id = config['id']
        self.level = 1
        self.max_level = config.get('max_level', 5)
        self.last_shot = 0
        self.init_stats()

    def init_stats(self):
        """è§£æ JSON ä¸­çš„ç­‰çº§æ•°æ®"""
        lvl_key = str(self.level)
        lvl_data = self.config.get('levels', {}).get(lvl_key, {})
        self.damage = lvl_data.get('damage', 10)
        self.cooldown = lvl_data.get('cooldown', 500)
        self.bullet_count = lvl_data.get('count', 1)

    def level_up(self):
        if self.level < self.max_level:
            self.level += 1
            self.init_stats()
            print(f"ğŸ” {self.config['name']} å‡çº§ -> LV.{self.level}")

    def update(self, dt, enemies):
        pass # ç”±å­ç±»é‡å†™
==============================
FILE: combat\weapons\cyber_aura.py
==============================
import pygame
from core.registry import registry
from combat.weapons.base_weapon import BaseWeapon

@registry.register_logic("cyber_aura")
class CyberAuraWeapon(BaseWeapon):
    def __init__(self, player, groups, config):
        super().__init__(player, groups, config)
        self.tick_timer = 0
        self.aura_surface = None
        self._update_visuals()

    def init_stats(self):
        """ä» JSON ç­‰çº§è¡¨æ›´æ–°å±æ€§"""
        super().init_stats() # è°ƒç”¨åŸºç±»è¯»å– level_data
        lvl_data = self.config['levels'].get(str(self.level), {})
        self.radius = lvl_data.get('radius', 150)
        self.tick_rate = lvl_data.get('tick_rate', 0.5)
        # è”åŠ¨ StatsComponent çš„ä¼¤å®³å€ç‡
        self.final_damage = self.damage * self.player.stats.damage_mult.value
        self._update_visuals()

    def _update_visuals(self):
        """æ ¹æ®åŠå¾„é¢„æ¸²æŸ“å…‰ç¯ï¼ŒèŠ‚çœæ¯ä¸€å¸§çš„ç»˜å›¾å¼€é”€"""
        size = self.radius * 2
        self.aura_surface = pygame.Surface((size, size), pygame.SRCALPHA)
        # èµ›åšè“æ¸å˜
        pygame.draw.circle(self.aura_surface, (0, 255, 240, 40), (self.radius, self.radius), self.radius)
        pygame.draw.circle(self.aura_surface, (0, 255, 240, 160), (self.radius, self.radius), self.radius, 2)

    def update(self, dt, enemies):
        # å®šæ—¶å™¨åˆ¤å®šä¼¤å®³è§¦å‘
        self.tick_timer += dt
        if self.tick_timer >= self.tick_rate:
            self._apply_aoe(enemies)
            self.tick_timer = 0

    def _apply_aoe(self, enemies):
        # è·å–ç©å®¶ä¸­å¿ƒç‚¹
        p_pos = self.player.pos
        # åˆ¤å®šèŒƒå›´å†…æ‰€æœ‰æ•Œäºº
        for enemy in enemies:
            if p_pos.distance_to(enemy.pos) <= self.radius:
                # é€ æˆä¼¤å®³å¹¶è§¦å‘å‡»é€€ï¼ˆå¦‚æœéœ€è¦ï¼‰
                enemy.take_damage(self.final_damage)

    def draw_custom(self, screen, offset):
        """å¦‚æœéœ€è¦ç‹¬ç«‹ç»˜åˆ¶ç‰¹æ•ˆï¼Œå¯ç”± CameraGroup è°ƒç”¨"""
        if self.aura_surface:
            render_pos = self.player.rect.center - offset
            rect = self.aura_surface.get_frect(center=render_pos)
            screen.blit(self.aura_surface, rect)
==============================
FILE: combat\weapons\orbital.py
==============================
import pygame
import math
from core.registry import registry
from combat.weapons.base_weapon import BaseWeapon


@registry.register_logic("orbital")  # <--- è¡¥ä¸Šè¿™ä¸€å¥
class OrbitalWeapon(BaseWeapon):
    def __init__(self, player, groups, config):
        super().__init__(player, groups, config)
        self.angle = 0
        self.radius = 120
        # è§†è§‰ï¼šåˆ›å»ºä¸€ä¸ªå¸¸é©»å…‰ç¯ Surface
        self.image = pygame.Surface((40, 40), pygame.SRCALPHA)
        pygame.draw.circle(self.image, (0, 255, 255, 100), (20, 20), 20, 3)

    def update(self, dt, enemies):
        self.angle += 5 * dt
        # ç¯ç»•é€»è¾‘
        offset = pygame.math.Vector2(math.cos(self.angle), math.sin(self.angle)) * self.radius
        current_pos = self.player.pos + offset

        # ç®€æ˜“ç¢°æ’ï¼šå…‰ç¯èŒƒå›´å†…æ•Œäººå—ä¼¤
        for enemy in enemies:
            if current_pos.distance_to(enemy.pos) < 30:
                enemy.take_damage(self.damage * dt * 5)

    def draw_custom(self, screen, offset):
        """å¦‚æœæƒ³è®©ç¯ç»•æ­¦å™¨ä¹Ÿæœ‰ç‰¹æ®Šç‰¹æ•ˆç»˜åˆ¶ï¼Œå¯ä»¥åœ¨è¿™é‡Œå†™é€»è¾‘"""
        pass
==============================
FILE: combat\weapons\projectile.py
==============================
import pygame
from core.registry import registry
from combat.weapons.base_weapon import BaseWeapon
from combat.projectiles.bullet import Bullet
from combat.combat_utils import CombatUtils

@registry.register_logic("projectile")  # <--- è¡¥ä¸Šè¿™ä¸€å¥
class ProjectileWeapon(BaseWeapon):
    def update(self, dt, enemies):
        now = pygame.time.get_ticks()
        # è‡ªåŠ¨è¯»å– Player çš„å†·å´ç¼©å‡å±æ€§
        cdr = getattr(self.player.stats, 'cooldown_reduction', None)
        reduction = cdr.value if cdr else 0

        if now - self.last_shot >= self.cooldown * (1 - reduction):
            target = CombatUtils.get_nearest_enemy(self.player.pos, enemies)
            if target:
                self.fire(target)
                self.last_shot = now

    def fire(self, target):
        direction = (target.pos - self.player.pos).normalize()
        for i in range(self.bullet_count):
            angle_offset = (i - (self.bullet_count - 1) / 2) * 10
            # è¿™é‡Œ groups å·²ç»åœ¨ BaseWeapon.__init__ ä¸­ä¿å­˜ä¸º self.groups
            Bullet(self.player.pos, direction.rotate(angle_offset), self.groups, self.damage)
==============================
FILE: combat\weapons\__init__.py
==============================

==============================
FILE: entities\base_entity.py
==============================
import pygame
from core.constants import *

class BaseEntity(pygame.sprite.Sprite):
    def __init__(self, pos, groups, layer=LAYER_BG):
        super().__init__(groups)
        self.z_index = layer
        self.pos = pygame.math.Vector2(pos)
        self.image = pygame.Surface((TILE_SIZE, TILE_SIZE), pygame.SRCALPHA)
        self.rect = self.image.get_rect(center=pos)

    def update(self, dt):
        pass
==============================
FILE: entities\player.py
==============================
import pygame
from entities.base_entity import BaseEntity
from entities.components.stats import StatsComponent
from core.constants import *


class Player(BaseEntity):
    def __init__(self, pos, groups, engine):  # å¢åŠ  engine å‚æ•°
        super().__init__(pos, groups, LAYER_PLAYER)
        self.engine = engine  # å…³é”®ï¼šä¿å­˜å¼•æ“å¼•ç”¨
        self.stats = StatsComponent({})

        self.image = pygame.Surface((40, 40), pygame.SRCALPHA)
        pygame.draw.circle(self.image, COLOR_PLAYER, (20, 20), 20)
        self.rect = self.image.get_rect(center=pos)
        self.pos = pygame.math.Vector2(self.rect.center)

        self.current_hp = self.stats.max_health.value
        self.current_xp = 0
        self.xp_required = 100
        self.level = 1
        self.vulnerable = True
        self.hurt_time = 0

    def take_damage(self, amount):
        if self.vulnerable:
            self.current_hp -= amount
            self.vulnerable = False
            self.hurt_time = pygame.time.get_ticks()

    def gain_xp(self, amount):
        self.current_xp += amount

    def perform_level_up(self):
        self.level += 1
        self.current_xp -= self.xp_required
        self.xp_required = int(self.xp_required * 1.3)
        self.current_hp = self.stats.max_health.value

    def update(self, dt):
        keys = pygame.key.get_pressed()
        direction = pygame.math.Vector2(
            (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT]),
            (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
        )
        if direction.length() > 0: direction = direction.normalize()
        self.pos += direction * self.stats.move_speed.value * dt
        self.rect.center = (round(self.pos.x), round(self.pos.y))

        if not self.vulnerable:
            if pygame.time.get_ticks() - self.hurt_time >= 500:
                self.vulnerable = True
==============================
FILE: entities\components\stats.py
==============================
class Stat:
    """å±æ€§å®¹å™¨ï¼šæ”¯æŒåŸºç¡€å€¼ã€åŠ æ³•åŠ æˆã€ç™¾åˆ†æ¯”åŠ æˆ"""

    def __init__(self, base_value):
        self.base_value = base_value
        self.flat_modifier = 0
        self.percent_modifier = 0

    @property
    def value(self):
        # å·¥ä¸šæ ‡å‡†å…¬å¼ï¼šæœ€ç»ˆå€¼ = (åŸºç¡€ + å›ºå®šåŠ æˆ) * (1 + ç™¾åˆ†æ¯”åŠ æˆ)
        return (self.base_value + self.flat_modifier) * (1 + self.percent_modifier)


class StatsComponent:
    def __init__(self, config):
        # åŸºç¡€å±æ€§
        self.health = Stat(config.get('health', 100))
        self.max_health = Stat(config.get('health', 100))
        self.move_speed = Stat(config.get('move_speed', 350))

        # æˆ˜æ–—å±æ€§ï¼ˆå†—ä½™è®¾è®¡ï¼šå“ªæ€•ç°åœ¨ä¸ç”¨ï¼Œä¹Ÿå…ˆé¢„ç•™ä½ç½®ï¼‰
        self.damage_mult = Stat(1.0)  # ä¼¤å®³å€ç‡
        self.attack_area = Stat(1.0)  # æ”»å‡»èŒƒå›´å€ç‡
        self.cooldown_reduction = Stat(0.0)  # å†·å´ç¼©å‡
        self.crit_rate = Stat(0.05)  # æš´å‡»ç‡
        self.crit_dmg = Stat(1.5)  # æš´å‡»ä¼¤å®³

        # å®ç”¨å±æ€§
        self.pickup_range = Stat(120)  # ç£å¸èŒƒå›´
        self.luck = Stat(1.0)  # å¹¸è¿
        self.exp_gain = Stat(1.0)  # ç»éªŒè·å–ç‡

    def add_modifier(self, stat_name, val, is_percent=True):
        """ä¸ºç‰¹å®šå±æ€§æ·»åŠ åŠ æˆ"""
        stat = getattr(self, stat_name, None)
        if stat:
            if is_percent:
                stat.percent_modifier += val
            else:
                stat.flat_modifier += val
==============================
FILE: entities\components\__init__.py
==============================

==============================
FILE: entities\enemies\base_enemy.py
==============================
import pygame
import random
from entities.base_entity import BaseEntity
from entities.components.stats import StatsComponent
from core.constants import *


class Enemy(BaseEntity):
    def __init__(self, pos, groups, config, player):
        super().__init__(pos, groups, LAYER_ENEMY)
        self.player = player
        self.config = config

        # æŒ‚è½½å±æ€§ç»„ä»¶
        self.stats = StatsComponent(config)
        self.hp = self.stats.health.value

        # è§†è§‰
        self.image = pygame.Surface((30, 30), pygame.SRCALPHA)
        pygame.draw.rect(self.image, COLOR_ENEMY, (0, 0, 30, 30), border_radius=4)
        self.rect = self.image.get_rect(center=pos)

    def update(self, dt):
        # åŸºç¡€è¿½å‡»é€»è¾‘
        direction = self.player.pos - self.pos
        if direction.length() > 0:
            direction = direction.normalize()

        self.pos += direction * self.stats.move_speed.value * dt
        self.rect.center = (round(self.pos.x), round(self.pos.y))

    def take_damage(self, amount):
        self.hp -= amount
        if self.hp <= 0:
            self.kill()
            return True  # è¿”å›æ­»äº¡ä¿¡å·
        return False
==============================
FILE: entities\enemies\__init__.py
==============================

==============================
FILE: entities\pickups\exp_gem.py
==============================
import pygame
from entities.base_entity import BaseEntity
from core.constants import *


class ExperienceGem(BaseEntity):
    def __init__(self, pos, groups, player):
        super().__init__(pos, groups, LAYER_PICKUP)
        self.player = player
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.polygon(self.image, (50, 255, 50), [(8, 0), (16, 8), (8, 16), (0, 8)])
        self.rect = self.image.get_rect(center=pos)
        self.pos = pygame.math.Vector2(pos)

        self.xp_value = 20
        self.speed = 0
        self.is_magnetized = False

    def update(self, dt):
        dist_vec = self.player.pos - self.pos
        distance = dist_vec.length()

        if distance < self.player.stats.pickup_range.value:
            self.is_magnetized = True

        if self.is_magnetized:
            self.speed += 40
            if distance > 0:
                self.pos += dist_vec.normalize() * self.speed * dt

        self.rect.center = (round(self.pos.x), round(self.pos.y))
==============================
FILE: entities\pickups\__init__.py
==============================

==============================
FILE: data\configs\characters.json
==============================
{
    "cypher_ghost": {
        "id": "cypher_ghost",
        "name": "èµ›åšå¹½çµ",
        "desc": "é«˜æœºåŠ¨æ€§ï¼Œæ“…é•¿è¿œç¨‹è¢­æ‰°ã€‚",
        "starting_weapon": "starter_gun",
        "base_stats": {
            "health": 80,
            "move_speed": 450,
            "damage_mult": 0.2
        }
    },
    "heavy_metal": {
        "id": "heavy_metal",
        "name": "é‡é‡‘å±",
        "desc": "è£…ç”²åšé‡ï¼Œè‡ªå¸¦é˜²å¾¡æ€§å…‰ç¯ã€‚",
        "starting_weapon": "cyber_aura",
        "base_stats": {
            "health": 200,
            "move_speed": 280,
            "damage_mult": 0.0
        }
    }
}
==============================
FILE: data\configs\upgrades.json
==============================
[
    {"id": "speed_up", "name": "ç¥ç»åŠ é€Ÿ", "desc": "ç§»åŠ¨é€Ÿåº¦ +15%", "stat": "move_speed", "value": 0.15},
    {"id": "atk_up", "name": "å¼ºåŠ›æ¨¡ç»„", "desc": "æ”»å‡»åŠ› +20%", "stat": "damage_mult", "value": 0.2},
    {"id": "pickup_up", "name": "ç£åŠ›æ‰©å®¹", "desc": "æ‹¾å–èŒƒå›´ +40%", "stat": "pickup_range", "value": 0.4},
    {"id": "hp_up", "name": "çº³ç±³è£…ç”²", "desc": "æœ€å¤§è¡€é‡ +20%", "stat": "max_health", "value": 0.2}
]
==============================
FILE: data\configs\enemies\basic_grunt.json
==============================
{
    "id": "basic_grunt",
    "name": "èµ›åšæ–°å…µ",
    "health": 30,
    "move_speed": 180,
    "score_value": 10,
    "logic_type": "chaser"
}
==============================
FILE: data\configs\weapons\cyber_aura.json
==============================
{
    "id": "cyber_aura",
    "name": "èµ›åšå…‰ç¯",
    "logic_type": "cyber_aura",
    "max_level": 5,
    "levels": {
        "1": {"damage": 12, "radius": 140, "tick_rate": 0.5},
        "2": {"damage": 15, "radius": 160, "tick_rate": 0.5},
        "3": {"damage": 18, "radius": 180, "tick_rate": 0.4},
        "4": {"damage": 22, "radius": 200, "tick_rate": 0.4},
        "5": {"damage": 30, "radius": 260, "tick_rate": 0.3}
    }
}
==============================
FILE: data\configs\weapons\starter.json
==============================
{
    "id": "starter_gun",
    "name": "èµ›åšå·¦è½®",
    "damage": 15,
    "logic_type": "projectile"
}
==============================
FILE: data\configs\weapons\starter_gun.json
==============================
{
    "id": "starter_gun",
    "name": "èµ›åšå·¦è½®",
    "logic_type": "projectile",
    "max_level": 5,
    "levels": {
        "1": {"damage": 15, "cooldown": 450, "count": 1, "desc": "åŸºç¡€å°„çº¿"},
        "2": {"damage": 18, "cooldown": 400, "count": 1, "desc": "å°„é€Ÿæå‡"},
        "3": {"damage": 18, "cooldown": 400, "count": 2, "desc": "åŒé‡è¿å‘"},
        "4": {"damage": 22, "cooldown": 350, "count": 2, "desc": "å¨åŠ›åŠ å¼º"},
        "5": {"damage": 25, "cooldown": 300, "count": 3, "desc": "ç«åŠ›å…¨å¼€"}
    }
}
==============================
FILE: main.py
==============================
from core.engine import GameEngine

if __name__ == '__main__':
    game = GameEngine()
    game.run()
==============================
FILE: setup_all.py
==============================
import os


def create_file(path, content):
    # ä¿®å¤ï¼šåªæœ‰å½“è·¯å¾„åŒ…å«ç›®å½•æ—¶æ‰åˆ›å»ºç›®å½•
    dir_name = os.path.dirname(path)
    if dir_name:
        os.makedirs(dir_name, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content.strip())
    print(f"âœ… Created: {path}")


# --- 1. æ ¸å¿ƒå®ªæ³•: constants.py ---
CONSTANTS_PY = """
import pygame
WIDTH, HEIGHT = 1280, 720
FPS = 60
TILE_SIZE = 64
# å·¥ä¸šçº§å›¾å±‚ç³»ç»Ÿ
LAYER_BG = 0
LAYER_PICKUP = 10
LAYER_ENEMY = 20
LAYER_PLAYER = 30
LAYER_PROJECTILE = 40
LAYER_UI = 100
# é…è‰²
COLOR_BG = (12, 12, 20)
COLOR_GRID = (30, 30, 50)
COLOR_PLAYER = (0, 255, 240)
COLOR_ENEMY = (255, 50, 80)
"""

# --- 2. å®ä½“åŸºç±»: base_entity.py (è§£è€¦æ ¸å¿ƒ) ---
BASE_ENTITY_PY = """
import pygame
from core.constants import *

class BaseEntity(pygame.sprite.Sprite):
    def __init__(self, pos, groups, layer=LAYER_BG):
        super().__init__(groups)
        self.z_index = layer
        self.pos = pygame.math.Vector2(pos)
        self.image = pygame.Surface((TILE_SIZE, TILE_SIZE), pygame.SRCALPHA)
        self.rect = self.image.get_rect(center=pos)

    def update(self, dt):
        pass
"""

# --- 3. å¹³æ»‘æ‘„åƒæœº: camera.py (æ‰“å‡»æ„Ÿæ ¸å¿ƒ) ---
CAMERA_PY = """
import pygame
from core.constants import *

class CameraGroup(pygame.sprite.Group):
    def __init__(self):
        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.offset = pygame.math.Vector2()

    def custom_draw(self, player):
        # ä¸æ»‘è·Ÿéš (Lerp)
        self.offset.x += (player.rect.centerx - WIDTH // 2 - self.offset.x) * 0.1
        self.offset.y += (player.rect.centery - HEIGHT // 2 - self.offset.y) * 0.1

        # ç»˜åˆ¶èƒŒæ™¯
        self.display_surface.fill(COLOR_BG)

        # æŒ‰ç…§ z_index å’Œ y åæ ‡æ’åºç»˜åˆ¶ (ä¼ª3D/å±‚çº§ç®¡ç†)
        for sprite in sorted(self.sprites(), key=lambda s: (getattr(s, 'z_index', 0), s.rect.centery)):
            offset_pos = sprite.rect.topleft - self.offset
            self.display_surface.blit(sprite.image, offset_pos)
"""

# --- 4. æ³¨å†Œä¸­å¿ƒ: registry.py (å³æ’å³ç”¨æ ¸å¿ƒ) ---
REGISTRY_PY = """
import os, json
class Registry:
    def __init__(self):
        self.weapons = {}
        self.enemies = {}
    def load(self):
        paths = {'weapons': 'data/configs/weapons', 'enemies': 'data/configs/enemies'}
        for key, path in paths.items():
            if not os.path.exists(path): os.makedirs(path); continue
            for f in os.listdir(path):
                if f.endswith(".json"):
                    with open(os.path.join(path, f), 'r', encoding='utf-8') as file:
                        data = json.load(file)
                        getattr(self, key)[data['id']] = data
        print(f"ğŸ“¦ Registry loaded: {len(self.weapons)} Weapons")
registry = Registry()
"""

# --- 5. æ ¸å¿ƒå¼•æ“: engine.py ---
ENGINE_PY = """
import pygame
from core.constants import *
from core.registry import registry
from core.camera import CameraGroup

class GameEngine:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True

        # åˆå§‹åŒ–æ ¸å¿ƒç³»ç»Ÿ
        registry.load()
        self.all_sprites = CameraGroup()

        # ä¸´æ—¶åˆ›å»ºä¸€ä¸ªç©å®¶å±•ç¤º
        from entities.player import Player
        self.player = Player((WIDTH//2, HEIGHT//2), [self.all_sprites])

    def run(self):
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            for event in pygame.event.get():
                if event.type == pygame.QUIT: self.running = False

            self.all_sprites.update(dt)
            self.all_sprites.custom_draw(self.player)
            pygame.display.flip()
"""

# --- 6. ç©å®¶å¤–å£³: player.py ---
PLAYER_PY = """
import pygame
from entities.base_entity import BaseEntity
from core.constants import *

class Player(BaseEntity):
    def __init__(self, pos, groups):
        super().__init__(pos, groups, LAYER_PLAYER)
        pygame.draw.circle(self.image, COLOR_PLAYER, (TILE_SIZE//2, TILE_SIZE//2), 20)
        self.speed = 400

    def update(self, dt):
        keys = pygame.key.get_pressed()
        direction = pygame.math.Vector2(
            (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT]),
            (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
        )
        if direction.length() > 0:
            direction = direction.normalize()
        self.pos += direction * self.speed * dt
        self.rect.center = (round(self.pos.x), round(self.pos.y))
"""

# --- 7. æ ·ä¾‹æ­¦å™¨æ•°æ® ---
WEAPON_JSON = """
{
    "id": "starter_gun",
    "name": "èµ›åšå·¦è½®",
    "damage": 15,
    "logic_type": "projectile"
}
"""

if __name__ == "__main__":
    create_file("core/constants.py", CONSTANTS_PY)
    create_file("core/camera.py", CAMERA_PY)
    create_file("core/registry.py", REGISTRY_PY)
    create_file("core/event_bus.py",
                "class EventBus:\\n    def __init__(self): self.listeners = {}\\n    def emit(self, e, **k): pass\\nbus = EventBus()")
    create_file("core/engine.py", ENGINE_PY)
    create_file("entities/base_entity.py", BASE_ENTITY_PY)
    create_file("entities/player.py", PLAYER_PY)
    create_file("entities/components/stats.py", "class StatsComponent:\\n    def __init__(self, config): pass")
    create_file("data/configs/weapons/starter.json", WEAPON_JSON)
    create_file("main.py", "from core.engine import GameEngine\\nif __name__ == '__main__':\\n    GameEngine().run()")

    # å»ºç«‹ç¼ºå¤±ç›®å½•
    for d in ["combat/weapons", "entities/enemies", "ui/hud", "assets/textures"]:
        os.makedirs(d, exist_ok=True)

    print("\\nğŸš€ [CyberSurvivor_Pro] å·¥ä¸šåŒ–æ¶æ„åˆå§‹åŒ–æˆåŠŸï¼è¯·è¿è¡Œ main.pyã€‚")
==============================
FILE: setup_final.py
==============================
import os


def create_file(path, content):
    dir_name = os.path.dirname(path)
    if dir_name:
        os.makedirs(dir_name, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content.strip())
    print(f"âœ… æˆåŠŸåˆ›å»º: {path}")


# --- 1. constants.py ---
CONSTANTS_PY = """
import pygame
WIDTH, HEIGHT = 1280, 720
FPS = 60
TILE_SIZE = 64
LAYER_BG, LAYER_PICKUP, LAYER_ENEMY, LAYER_PLAYER, LAYER_PROJECTILE, LAYER_UI = 0, 10, 20, 30, 40, 100
COLOR_BG = (12, 12, 20)
COLOR_GRID = (35, 35, 55)
COLOR_PLAYER = (0, 255, 240)
COLOR_ENEMY = (255, 50, 80)
"""

# --- 2. base_entity.py ---
BASE_ENTITY_PY = """
import pygame
from core.constants import *

class BaseEntity(pygame.sprite.Sprite):
    def __init__(self, pos, groups, layer=LAYER_BG):
        super().__init__(groups)
        self.z_index = layer
        self.pos = pygame.math.Vector2(pos)
        self.image = pygame.Surface((TILE_SIZE, TILE_SIZE), pygame.SRCALPHA)
        self.rect = self.image.get_rect(center=pos)

    def update(self, dt):
        pass
"""

# --- 3. camera.py ---
CAMERA_PY = """
import pygame
from core.constants import *

class CameraGroup(pygame.sprite.Group):
    def __init__(self):
        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.offset = pygame.math.Vector2()

    def custom_draw(self, player):
        # ä¸æ»‘è·Ÿéš (Lerp)
        self.offset.x += (player.rect.centerx - WIDTH // 2 - self.offset.x) * 0.1
        self.offset.y += (player.rect.centery - HEIGHT // 2 - self.offset.y) * 0.1

        self.display_surface.fill(COLOR_BG)

        # æ’åºç»˜åˆ¶
        for sprite in sorted(self.sprites(), key=lambda s: (getattr(s, 'z_index', 0), s.rect.centery)):
            offset_pos = sprite.rect.topleft - self.offset
            self.display_surface.blit(sprite.image, offset_pos)
"""

# --- 4. registry.py ---
REGISTRY_PY = """
import os, json
class Registry:
    def __init__(self):
        self.weapons = {}
        self.enemies = {}
    def load(self):
        paths = {'weapons': 'data/configs/weapons', 'enemies': 'data/configs/enemies'}
        for key, path in paths.items():
            if not os.path.exists(path): os.makedirs(path); continue
            for f in os.listdir(path):
                if f.endswith(".json"):
                    with open(os.path.join(path, f), 'r', encoding='utf-8') as file:
                        data = json.load(file)
                        self.__dict__[key][data['id']] = data
        print(f"ğŸ“¦ æ³¨å†Œä¸­å¿ƒå·²åŠ è½½æ­¦å™¨: {list(self.weapons.keys())}")
registry = Registry()
"""

# --- 5. engine.py ---
ENGINE_PY = """
import pygame
from core.constants import *
from core.registry import registry
from core.camera import CameraGroup
from entities.player import Player

class GameEngine:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True

        registry.load()
        self.all_sprites = CameraGroup()
        self.player = Player((WIDTH//2, HEIGHT//2), [self.all_sprites])

    def run(self):
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            for event in pygame.event.get():
                if event.type == pygame.QUIT: self.running = False

            self.all_sprites.update(dt)
            self.all_sprites.custom_draw(self.player)
            pygame.display.flip()
"""

# --- 6. player.py ---
PLAYER_PY = """
import pygame
from entities.base_entity import BaseEntity
from core.constants import *

class Player(BaseEntity):
    def __init__(self, pos, groups):
        super().__init__(pos, groups, LAYER_PLAYER)
        pygame.draw.circle(self.image, COLOR_PLAYER, (TILE_SIZE//2, TILE_SIZE//2), 20)
        self.speed = 400

    def update(self, dt):
        keys = pygame.key.get_pressed()
        direction = pygame.math.Vector2(
            (keys[pygame.K_d] or keys[pygame.K_RIGHT]) - (keys[pygame.K_a] or keys[pygame.K_LEFT]),
            (keys[pygame.K_s] or keys[pygame.K_DOWN]) - (keys[pygame.K_w] or keys[pygame.K_UP])
        )
        if direction.length() > 0:
            direction = direction.normalize()
        self.pos += direction * self.speed * dt
        self.rect.center = (round(self.pos.x), round(self.pos.y))
"""

# --- 7. main.py ---
MAIN_PY = """
from core.engine import GameEngine

if __name__ == '__main__':
    game = GameEngine()
    game.run()
"""

# --- æ‰§è¡Œ ---
if __name__ == "__main__":
    create_file("core/constants.py", CONSTANTS_PY)
    create_file("core/camera.py", CAMERA_PY)
    create_file("core/registry.py", REGISTRY_PY)
    create_file("core/engine.py", ENGINE_PY)
    create_file("entities/base_entity.py", BASE_ENTITY_PY)
    create_file("entities/player.py", PLAYER_PY)
    create_file("main.py", MAIN_PY)

    # åˆ›å»ºå¿…è¦çš„ç©ºç›®å½•
    for d in ["data/configs/weapons", "data/configs/enemies", "entities/components", "combat/weapons"]:
        os.makedirs(d, exist_ok=True)

    # åˆ›å»ºä¸€ä¸ªç©ºçš„ stats.py é˜²æ­¢å¯¼å…¥é”™è¯¯
    create_file("entities/components/stats.py", "class StatsComponent:\\n    def __init__(self, config): pass")
    # åˆ›å»ºä¸€ä¸ªç©ºçš„ event_bus.py
    create_file("core/event_bus.py", "class EventBus:\\n    def __init__(self): pass\\nbus = EventBus()")

    print("\nğŸš€ [CyberSurvivor_Pro] åˆå§‹åŒ–æˆåŠŸï¼è¯·è¿è¡Œ main.py æµ‹è¯•ã€‚")
==============================
FILE: setup_project.py
==============================
import os


def create_file(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content.strip())
    print(f"âœ… å·²åˆ›å»ºæ–‡ä»¶: {path}")


# --- 1. å…¨å±€å¸¸é‡ (Constitution) ---
CONSTANTS_PY = """
import pygame
WIDTH, HEIGHT = 1280, 720
FPS = 60
TILE_SIZE = 64
# æ¸²æŸ“å±‚çº§
LAYER_BG, LAYER_PICKUP, LAYER_ENEMY, LAYER_PLAYER, LAYER_PROJECTILE, LAYER_UI = 0, 10, 20, 30, 40, 100
# é…è‰²
COLOR_BG = (10, 10, 18)
COLOR_GRID = (35, 35, 60)
COLOR_PLAYER = (0, 255, 240)
COLOR_ENEMY = (255, 45, 85)
COLOR_TEXT = (245, 245, 245)
"""

# --- 2. è‡ªåŠ¨æ³¨å†Œä¸­å¿ƒ (The Brain) ---
REGISTRY_PY = """
import os, json
class Registry:
    def __init__(self):
        self.weapons = {}
        self.enemies = {}
        self.characters = {}
    def load(self):
        for cat in ['weapons', 'enemies', 'characters']:
            path = f"data/configs/{cat}"
            if not os.path.exists(path): os.makedirs(path); continue
            for f in os.listdir(path):
                if f.endswith(".json"):
                    with open(os.path.join(path, f), 'r', encoding='utf-8') as file:
                        data = json.load(file)
                        self.__dict__[cat][data['id']] = data
        print(f"ğŸ“¦ Registry loaded: {len(self.weapons)} Weapons")
registry = Registry()
"""

# --- 3. äº‹ä»¶æ€»çº¿ (The Nervous System) ---
EVENT_BUS_PY = """
class EventBus:
    def __init__(self):
        self.listeners = {}
    def subscribe(self, event_type, callback):
        if event_type not in self.listeners: self.listeners[event_type] = []
        self.listeners[event_type].append(callback)
    def emit(self, event_type, **kwargs):
        if event_type in self.listeners:
            for callback in self.listeners[event_type]: callback(**kwargs)
bus = EventBus()
"""

# --- 4. ä¸‡èƒ½å±æ€§ç»„ä»¶ (The Soul) ---
STATS_PY = """
class Attribute:
    def __init__(self, base):
        self.base = base
        self.flat = 0
        self.mult = 0
    @property
    def value(self):
        return (self.base + self.flat) * (1 + self.mult)

class StatsComponent:
    def __init__(self, config):
        self.hp = Attribute(config.get('hp', 100))
        self.speed = Attribute(config.get('speed', 400))
        self.atk = Attribute(config.get('atk', 10))
        self.crit_rate = Attribute(0.05)
        self.pickup_range = Attribute(150)
        # å†—ä½™ä½
        self.luck = Attribute(1.0)
        self.armor = Attribute(0)
"""

# --- 5. æ ·ä¾‹æ•°æ® (Content) ---
WEAPON_JSON = """
{
    "id": "starter_gun",
    "name": "åˆå§‹æœºæª",
    "atk": 12,
    "cooldown": 500,
    "pierce": 1,
    "logic": "projectile"
}
"""

# --- 6. æ ¸å¿ƒå¼•æ“ (The Heart) ---
ENGINE_PY = """
import pygame
from core.constants import *
from core.registry import registry
from core.event_bus import bus

class GameEngine:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        registry.load() # å¯åŠ¨å³åŠ è½½æ‰€æœ‰JSON

    def run(self):
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            for event in pygame.event.get():
                if event.type == pygame.QUIT: self.running = False
            self.screen.fill(COLOR_BG)
            pygame.display.flip()
"""

# --- æ‰§è¡Œåˆå§‹åŒ– ---
if __name__ == "__main__":
    create_file("core/constants.py", CONSTANTS_PY)
    create_file("core/registry.py", REGISTRY_PY)
    create_file("core/event_bus.py", EVENT_BUS_PY)
    create_file("entities/components/stats.py", STATS_PY)
    create_file("core/engine.py", ENGINE_PY)
    create_file("data/configs/weapons/starter_gun.json", WEAPON_JSON)
    create_file("main.py", "from core.engine import GameEngine\\nif __name__ == '__main__':\\n    GameEngine().run()")

    # å»ºç«‹å…¶ä»–å¿…è¦çš„ç©ºæ–‡ä»¶å¤¹
    dirs = ["assets/textures", "assets/sfx", "entities/enemies", "combat/weapons", "ui/hud"]
    for d in dirs: os.makedirs(d, exist_ok=True); print(f"ğŸ“ å·²åˆ›å»ºæ–‡ä»¶å¤¹: {d}")

    print("\\nğŸš€ [CyberSurvivor_Pro] å·¥ä¸šåŒ–åœ°åŸºæµ‡ç­‘å®Œæˆï¼è¯·ç›´æ¥è¿è¡Œ main.py æµ‹è¯•ã€‚")